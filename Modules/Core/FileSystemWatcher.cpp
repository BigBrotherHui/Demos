#include <QDir>
#include <QFileInfo>
#include <qDebug>
#include "FileSystemWatcher.h"

FileSystemWatcher* FileSystemWatcher::m_pInstance = NULL;

FileSystemWatcher::FileSystemWatcher(QObject* parent)
    : QObject(parent)
{

}

FileSystemWatcher* FileSystemWatcher::instance()
{
    if (m_pInstance == NULL)
    {
        m_pInstance = new FileSystemWatcher();
        m_pInstance->m_pSystemWatcher = new QFileSystemWatcher();
        m_pInstance->m_pContentsWatcher = new QFileSystemWatcher();
        // 连接QFileSystemWatcher的directoryChanged和fileChanged信号到相应的槽
        connect(m_pInstance->m_pSystemWatcher, SIGNAL(directoryChanged(QString)), m_pInstance, SLOT(directoryUpdated(QString)));
        connect(m_pInstance->m_pContentsWatcher, SIGNAL(fileChanged(QString)), m_pInstance, SLOT(fileUpdated(QString)));
    }
    return m_pInstance;
}

FileSystemWatcher::~FileSystemWatcher()
{
    if(m_pSystemWatcher)
    {
        m_pSystemWatcher->deleteLater();
        m_pSystemWatcher = nullptr;
    }
    if (m_pContentsWatcher)
    {
        m_pContentsWatcher->deleteLater();
        m_pContentsWatcher = nullptr;
    }
}

// 监控文件或目录
void FileSystemWatcher::addWatchPath(QString path)
{
    qDebug() << QString("Add to watch: %1").arg(path);
    // 添加监控路径
    m_pSystemWatcher->addPath(path);
    
    // 如果添加路径是一个目录，保存当前内容列表
    QFileInfo file(path);
    if (file.isDir())
    {
        const QDir dirw(path);
        for (auto p : m_currentContentsMap[path])
        {
            m_pContentsWatcher->removePath(path + "/" + p);
        }
        m_currentContentsMap[path] = dirw.entryList(QDir::NoDotAndDotDot | QDir::AllDirs | QDir::Files, QDir::DirsFirst);
        for(auto p : m_currentContentsMap[path])
        {
            m_pContentsWatcher->addPath(path + "/"+p);
        }
    }
}

// 只要任何监控的目录更新（添加、删除、重命名），就会调用。
void FileSystemWatcher::directoryUpdated(const QString& path)
{
    // 比较最新的内容和保存的内容找出区别(变化)
    QStringList currEntryList = m_currentContentsMap[path];
    const QDir dir(path);

    QStringList newEntryList = dir.entryList(QDir::NoDotAndDotDot | QDir::AllDirs | QDir::Files, QDir::DirsFirst);

    QSet<QString> newDirSet = QSet<QString>::fromList(newEntryList);
    QSet<QString> currentDirSet = QSet<QString>::fromList(currEntryList);

    // 添加了文件
    QSet<QString> newFiles = newDirSet - currentDirSet;
    QStringList newFile = newFiles.toList();
    
    // 文件已被移除
    QSet<QString> deletedFiles = currentDirSet - newDirSet;
    QStringList deleteFile = deletedFiles.toList();

    // 更新当前设置
    m_currentContentsMap[path] = newEntryList;
    for (auto p : m_currentContentsMap[path])
    {
        m_pContentsWatcher->removePath(path + "/" + p);
    }
    for (auto p : m_currentContentsMap[path])
    {
        m_pContentsWatcher->addPath(path + "/" + p);
    }
    if (!newFile.isEmpty() && !deleteFile.isEmpty())
    {
        // 文件/目录重命名
        if ((newFile.count() == 1) && (deleteFile.count() == 1))
        {
            qDebug() << QString("File Renamed from %1 to %2").arg(deleteFile.first()).arg(newFile.first());
        }
    }
    else
    {
        // 添加新文件/目录至Dir
        if (!newFile.isEmpty())
        {
            qDebug() << "New Files/Dirs added: " << newFile;

            foreach(QString file, newFile)
            {
                // 处理操作每个新文件....
            }
            emit signal_directoryUpdated(0, newFile);
        }

        // 从Dir中删除文件/目录
        if (!deleteFile.isEmpty())
        {
            qDebug() << "Files/Dirs deleted: " << deleteFile;

            foreach(QString file, deleteFile)
            {
                // 处理操作每个被删除的文件....
            }
            emit signal_directoryUpdated(1, deleteFile);
        }

        //覆盖
        if(newFile.isEmpty() && deleteFile.isEmpty())
        {
            //emit signal_directoryUpdated(2, QStringList());
        }
    }
}

// 文件修改时调用
void FileSystemWatcher::fileUpdated(const QString& path)
{
    QFileInfo file(path);
    QString strPath = file.absolutePath();
    QString strName = file.fileName();
    if(!m_file_update_time_map.contains(path))
    {
		m_file_update_time_map[path]= QDateTime::currentDateTime();
    }
	else if (m_file_update_time_map[path].msecsTo(QDateTime::currentDateTime()) < 500)
    {
		return;
    }
    m_file_update_time_map[path] = QDateTime::currentDateTime();
    emit signal_directoryUpdated(2, QStringList() << strPath + "/" + strName);
}
